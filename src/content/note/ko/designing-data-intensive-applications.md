---
title: Designing Data-Intensive Applications
timestamp: 2025-08-29
tags:
  - book
aliases:
---

**책 제목**: [데이터 중심 애플리케이션 설계](https://product.kyobobook.co.kr/detail/S000001766328)

굉장히 좋은 책 중 하나이다.

데이터 중심 어플리케이션은 CPU 계산 복잡도보다 데이터의 저장, 이동, 일관성, 장애 대응이 시스템의 병목이 되는 애플리케이션이다. 복잡한 CPU 연산 로직을 처리하는 것이 아닌, 우리가 자주 말하는 "프로덕트"에 가까운 도메인 데이터를 처리하는 것이 주된 목적이다. 이러한 관점에서 해당 책은 내용이 상당히 방대하고 복잡하지만 백엔드 개발자를 꿈꾸고 있다면 한 번 쯤은 읽어보는 것을 추천한다.

이 책은 특정한 기술을 다루기 보다는 그 기술들의 근원이 되는 지식들을 다룬다.

## 책의 구성

이 책은 크게 3개의 파트로 나뉘어져 있다:

### Part 1: 데이터 시스템의 기초

첫 번째 파트에서는 데이터 시스템을 구성하는 기본적인 개념들을 다룬다. **신뢰성(Reliability)**, **확장성(Scalability)**, **유지보수성(Maintainability)** 이 세 가지 핵심 개념은 모든 데이터 중심 애플리케이션이 추구해야 할 목표다.

- **신뢰성**: 시스템이 예상치 못한 상황에서도 올바르게 동작해야 한다. 하드웨어 장애, 소프트웨어 오류, 인적 오류 등 다양한 장애 상황에 대비해야 한다.
- **확장성**: 데이터 양, 트래픽, 복잡도가 증가해도 시스템이 이를 처리할 수 있어야 한다. 부하를 측정하고, 성능을 기술하며, 부하 증가에 대응하는 방법을 이해해야 한다.
- **유지보수성**: 시간이 지나도 시스템을 효율적으로 운영하고 개선할 수 있어야 한다. 운용성, 단순성, 발전성이 중요하다.

또한 다양한 **데이터 모델**(관계형, 문서형, 그래프형)과 **질의 언어**를 비교하며, 각각의 장단점과 적합한 사용 사례를 설명한다. 데이터베이스 내부에서 데이터가 어떻게 저장되고 검색되는지를 이해하는 **저장소 엔진**에 대한 내용도 포함된다.

### Part 2: 분산 데이터

두 번째 파트는 여러 머신에 데이터를 분산 저장하는 방법을 다룬다. 현대의 대부분의 시스템은 단일 머신으로는 처리할 수 없는 규모의 데이터를 다루기 때문에 이 부분이 특히 중요하다.

**복제(Replication)**는 같은 데이터를 여러 노드에 복사하여 저장하는 기법이다. 단일 리더, 다중 리더, 리더 없는 복제 방식을 비교하며, 각각의 트레이드오프를 설명한다. 복제 지연으로 인한 일관성 문제와 이를 해결하는 다양한 방법들도 다룬다.

**파티셔닝(Partitioning)**은 큰 데이터셋을 여러 파티션으로 나누어 저장하는 기법이다. 키 범위 기반 파티셔닝, 해시 기반 파티셔닝 등 다양한 전략과 파티셔닝된 데이터베이스에서 쿼리를 처리하는 방법을 설명한다.

**트랜잭션**은 여러 읽기와 쓰기를 하나의 논리적 단위로 묶는 메커니즘이다. ACID 속성, 격리 수준, 동시성 제어 등 트랜잭션의 핵심 개념을 깊이 있게 다룬다.

**분산 시스템의 문제점**도 상세히 다룬다. 네트워크 장애, 시계 동기화 문제, 부분 장애 등 분산 환경에서 발생할 수 있는 다양한 문제와 이를 해결하기 위한 합의 알고리즘, 일관성 보장 방법 등을 설명한다.

### Part 3: 파생 데이터

세 번째 파트는 하나의 데이터셋에서 다른 데이터셋을 파생시키는 시스템을 다룬다.

**배치 처리(Batch Processing)**는 대량의 데이터를 한 번에 처리하는 방법이다. MapReduce, 데이터플로우 엔진 등의 개념과 실제 구현 사례를 다룬다.

**스트림 처리(Stream Processing)**는 실시간으로 들어오는 데이터를 처리하는 방법이다. 이벤트 스트림, 메시지 브로커, 스트림 처리 프레임워크 등을 설명한다.

## 핵심 인사이트

이 책을 읽으면서 얻을 수 있는 가장 큰 가치는 **트레이드오프를 이해하는 능력**이다. 완벽한 데이터베이스나 완벽한 아키텍처는 존재하지 않는다. 모든 선택에는 장단점이 있으며, 상황에 맞는 최선의 선택을 하는 것이 중요하다.

예를 들어:
- **일관성 vs 가용성**: CAP 정리에 따르면 분산 시스템에서 일관성, 가용성, 분할 내성을 모두 만족시킬 수 없다.
- **정규화 vs 비정규화**: 관계형 모델의 정규화는 데이터 중복을 줄이지만 조인 비용이 발생한다. 문서형 모델의 비정규화는 조인을 피할 수 있지만 데이터 중복이 발생한다.
- **동기 vs 비동기**: 동기 복제는 강한 일관성을 보장하지만 성능이 떨어진다. 비동기 복제는 성능이 좋지만 일관성 문제가 발생할 수 있다.

## 백엔드 개발자에게 주는 교훈

이 책은 단순히 이론만 다루는 것이 아니라, 실제 프로덕션 환경에서 마주칠 수 있는 문제들과 그 해결 방법을 제시한다. PostgreSQL, MySQL, MongoDB, Cassandra, Kafka 등 실제로 사용되는 시스템들의 내부 동작 원리를 이해할 수 있다.

특히 다음과 같은 질문들에 대한 답을 찾을 수 있다:
- 왜 인덱스를 추가하면 조회는 빨라지지만 쓰기는 느려질까?
- 왜 분산 시스템에서는 시간을 신뢰할 수 없을까?
- 왜 eventual consistency가 필요할까?
- 왜 트랜잭션 격리 수준이 여러 개 존재할까?

## 마치며

이 책은 쉽지 않다. 600페이지가 넘는 분량에 다루는 내용도 방대하다. 하지만 백엔드 개발자로서 성장하고 싶다면, 그리고 단순히 프레임워크를 사용하는 것을 넘어 시스템을 설계하고 싶다면 반드시 읽어볼 가치가 있다.

한 번에 모든 내용을 이해하려고 하지 말고, 필요한 부분부터 천천히 읽어나가는 것을 추천한다. 실무에서 마주치는 문제들과 연결지어 생각하면 더욱 깊이 있는 이해가 가능할 것같다.